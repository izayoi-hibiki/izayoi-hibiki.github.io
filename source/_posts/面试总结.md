---
title: 面试总结
categories:
    - Web前端
date: 2020-10-16 11:46:42
tags:
    - 面试
mathjax: true
---

近期面试了几家公司攒攒经验，记一下遇到的问题。

<!--more-->

# addEventListener

面试时被问到这个 API，因为工作中没怎么用过，就按记忆说的，前两个参数说对了，第三个参数忘了，面试官告诉我说是阻止事件冒泡的。后来查了一下，他说的也不完整，应该是 addEventListener 第三个参数接受一个布尔值，指定事件在冒泡阶段还是捕获阶段执行，默认 false，事件在冒泡阶段执行，true 为事件在捕获阶段执行，变相的达到了阻止事件冒泡的目的。
又问了其他的阻止事件冒泡的方法，我说了 Vue 的 .stop，问还有么，我说的 preventDefault，后来查了应该是 event.stopPropagation，我把阻止默认行为和阻止冒泡搞混了。

# 变量提升

```JavaScript
var num = 100;
function a(){
    var num = ++num;
    console.log(num);
}
```

问执行结果，由于 var 声明的变量会提升，所以在 `var num = ++num;` 前会隐含一句 `var num = undefined;`，所以 ++num 就会变成 ++undefined，结果是非数 NaN。

# 一道动归
这题是我这几次面试遇到最有技术含量的一道题了（虽然在 leetcode 上可能会被分类成 esay），后来一查居然是网上的原题。。。思路和我的基本一样。

问：Z 国的货币系统包含面值 1 元、4 元、16 元、64 元共计 4 种硬币，以及面值 1024 元的纸币。现在小 Y 使用 1024 元的纸币购买了一件价值为 N 的商品，请问最少他会收到多少硬币？

状态转移方程：

```text
dp[1024-N] = min{dp[1024-N-1]+1,dp[1024-N-4]+1,dp[1024-N-16]+1,dp[1024-N-64]+1}     0 < N < 1024
dp[1024-N] = 0                                                                      N = 1024
```

找零只能是 1024-N 元，1024-N 元的找法可以是 1024-N-1 元的最少找法再加上一张 1 元的，或者是 1024-N-4 元的最少找法再加上一张 4 元的，或者是 1024-N-16 元的最少找法再加上一张 16 元的，或者是 1024-N-64 元的最少找法再加上一张 64 元的；总共就这 4 种类型，那我们只要看这四类哪类找法是最少的就好了，这就是标准的动态规划思路，当前的状态可以依据之前的状态得出。用一个字典从找 0 元开始记录，迭代求出 0 到 1024 元的找法并记录就好了。
示例代码：

```JavaScript
function solution(n) {
    let N = 1024;
    let dp = [];
    dp[1024 - N] = 0;
    N--;
    dp[1024 - N] = 1;
    const INF = Number.POSITIVE_INFINITY;
    while (N >= 0) {
        dp[1024 - N] = Math.min(
            1024 - N - 1 >= 0 ? dp[1024 - N - 1] + 1 : INF,
            1024 - N - 4 >= 0 ? dp[1024 - N - 4] + 1 : INF,
            1024 - N - 16 >= 0 ? dp[1024 - N - 16] + 1 : INF,
            1024 - N - 64 >= 0 ? dp[1024 - N - 64] + 1 : INF
        );
        N--;
    }
    console.log(dp);
    return dp[1024 - n];
}
let r = solution(1020);
console.log(r);          //1
```

# 三次握手和四次挥手
先贴张《计算机网络 自顶向下方法》的插图：TCP报文段结构

{% asset_img 01.jpg TCP报文段结构 %}

{% asset_img 02.jpg 三次握手 %}

这里要注意的是 ACK 在第一次握手的时候是 0，之后每次发送的报文段的 ACK 都是 1，ACK 表示确认收到了上一个报文段。而前两次握手的 SYN 是置为 1 的，表示要建立连接，连接已经建立，之后的每一个报文段都要将 SYN 置为 0。前两次握手不会附带数据，第三次握手的时候就可以附带数据了。
ack 和 ACK 是两个不同的东西，ACK 是报文段 6 位标志字段的其中一位，用于指示确认字段中的值是有效的，即该报文段包括一个对已成功接收的报文段的确认。而 ack 全称是 acknowledge number，确认号是对已接收的报文段的序号 seq 加一得来，用于接收方确认自己上一次发出的报文被成功接收。

{% asset_img 03.jpg 四次挥手 %}
四次挥手，客户应用进程发出一个关闭连接的命令，会引起客户 TCP 向服务端发送一个特殊的报文段，这个报文段的首部 FIN 位被置为 1，表示请求关闭连接。服务端收到这个报文段后会向发送方发送一个确认报文段，等到服务端的数据发送完毕后，会向客户端发送一个终止连接的报文段，其首部 FIN 位也被置为 1，客户端收到之后发送一个确认报文段，至此连接被关闭，所有应用于该连接的资源都被释放了。

# 另外几个特别爱问的
Vue双向绑定原理，computed 和 watch 区别，有家公司三面问了三遍（貌似）
SEO，前端性能优化，跨域，笔试题跨域特别爱问，但是面试没遇到问跨域的
面试问到实现一个 Vue 指令，我没怎么用过，回头看了下文档也没见什么难的啊，就照文档写呗
还有 JS 有几种继承，优缺点。